crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，
但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，
这样用起来方便，运行速度也快。

md5和sha1

const crypto = require('crypto');
const hash = crypto.createHash('md5')//sha1

// 可任意多次调用update():
hash.update('hello,world');
hash.update(hello,nodejs)；
console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544
//hex是16进制 可以用base64......

update()方法默认字符串编码为UTF-8，也可以传入Buffer。

如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。

还可以使用更安全的sha256和sha512。


Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。
不同的是，Hmac还需要一个密钥：

const crypto = require('crypto');

const hmac = crypto.createHmac('sha256', 'secret-key');

hmac.update('Hello, world!');
hmac.update('Hello, nodejs!');

console.log(hmac.digest('hex')); // 80f7e22570...
只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，
因此，可以把Hmac理解为用随机数“增强”的哈希算法。



TypeError: HashUpdate fail  第一次不会报错，后面就会报这种错误

'use strict'
const express = require('express');
const crypto = require('crypto');

//const hash = crypto.createHash('sha1');  写在这里则会报错

module.exports = express.Router()
    .get('/',function(req,res){
        res.render('index',{
            issuccess: true
        })
    })
    .get('/test',function(req,res){
        res.render('test',{
            data: 'Hello World!'
        })
    })
    .get('/interface',(req,res)=>{
        var token = 'weixin';
        var signature = req.query.signature;
        let timestamp = req.query.timestamp;
        let echostr = req.query.echostr;
        let nonce = req.query.nonce;
        var arr = [];
        arr.push(nonce,timestamp,token);
        var original = arr.sort().join('');
        let returnData = toHash(original);  //在调用的时候重新执行createHash
        if(signature === returnData){
            res.send(echostr);
        }
    })
    .post('/interface',(req,res)=>{})
	

function toHash(data){
    const hash = crypto.createHash('sha1');   //在这里每次执行toHash时重新创建
    return hash.update(data).digest('hex')
}